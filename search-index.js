var searchIndex = {};
searchIndex["boolean_expression"] = {"doc":"boolean_expression expression manipulation / BDD library","items":[[3,"BDD","boolean_expression","A `BDD` is a Binary Decision Diagram, an efficient way to represent a Boolean function in a canonical way. (It is actually a \"Reduced Ordered Binary Decision Diagram\", which gives it its canonicity assuming terminals are ordered consistently.)",null,null],[3,"PersistedBDD","","A `PersistedBDD` is a wrapper around a `BDD` that provides a means to write BDD labels and nodes out to a `BDDOutput`. It tracks how much of the BDD has already been writen out, and writes out new nodes and labels as required when its `persist()` or `persist_all()` method is called.",null,null],[3,"BDDLoader","","A `BDDLoader` provides a way to inject BDD nodes directly, as they were previously dumped by a `PersistedBDD` to a `BDDOutput`. The user should create a `BDDLoader` instance wrapped around a `BDD` and call `inject_label` and `inject_node` as appropriate to inject labels and nodes.",null,null],[3,"Cube","","A `Cube` is one (multidimensional) cube in the variable space: i.e., a particular set of variable assignments, where each variable is assigned either true, false, or \"don't care\".",null,null],[3,"CubeList","","A `CubeList` is a sum (OR'd list) of cubes. It represents a Boolean expression in sum-of-products form, by construction.",null,null],[4,"Expr","","An `Expr` is a simple Boolean logic expression. It may contain terminals (i.e., free variables), constants, and the following fundamental operations: AND, OR, NOT.",null,null],[13,"Terminal","","A terminal (free variable). This expression node represents a value that is not known until evaluation time.",0,null],[13,"Const","","A boolean constant: true or false.",0,null],[13,"Not","","The logical complement of the contained expression argument.",0,null],[13,"And","","The logical AND of the two expression arguments.",0,null],[13,"Or","","The logical OR of the two expression arguments.",0,null],[4,"CubeVar","","A variable assignment in a cube.",null,null],[13,"False","","This variable must be false.",1,null],[13,"True","","This variable must be true.",1,null],[13,"DontCare","","This variable may be true or false.",1,null],[4,"CubeMergeResult","","The result of attempting to merge two cubes.",null,null],[13,"None","","The cubes could not be merged.",2,null],[13,"CancelLeft","","The left cube was canceled because it is completely covered by the right cube.",2,null],[13,"CancelRight","","The right cube was canceled because it is completely covered by the left cube.",2,null],[13,"Merge","","The two cubes merge into one.",2,null],[13,"ExpandLeft","","The left cube may be expanded (increase its number of `DontCare`s) by overlapping with the right cube.",2,null],[13,"ExpandRight","","The right cube may be expanded (increase its number of `DontCare`s) by overlapping with the left cube.",2,null],[11,"clone","","",0,{"inputs":[{"name":"self"}],"output":{"name":"expr"}}],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",0,{"inputs":[{"name":"self"},{"name":"expr"}],"output":{"name":"bool"}}],[11,"ne","","",0,{"inputs":[{"name":"self"},{"name":"expr"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",0,{"inputs":[{"name":"self"},{"name":"expr"}],"output":{"generics":["ordering"],"name":"option"}}],[11,"lt","","",0,{"inputs":[{"name":"self"},{"name":"expr"}],"output":{"name":"bool"}}],[11,"le","","",0,{"inputs":[{"name":"self"},{"name":"expr"}],"output":{"name":"bool"}}],[11,"gt","","",0,{"inputs":[{"name":"self"},{"name":"expr"}],"output":{"name":"bool"}}],[11,"ge","","",0,{"inputs":[{"name":"self"},{"name":"expr"}],"output":{"name":"bool"}}],[11,"cmp","","",0,{"inputs":[{"name":"self"},{"name":"expr"}],"output":{"name":"ordering"}}],[11,"hash","","",0,null],[11,"is_terminal","","Returns `true` if this `Expr` is a terminal.",0,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_const","","Returns `true` if this `Expr` is a constant.",0,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_not","","Returns `true` if this `Expr` is a NOT node.",0,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_and","","Returns `true` if this `Expr` is an AND node.",0,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_or","","Returns `true` if this `Expr` is an OR node.",0,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"not","","Builds a NOT node around an argument, consuming the argument expression.",0,{"inputs":[{"name":"expr"}],"output":{"name":"expr"}}],[11,"and","","Builds an AND node around two arguments, consuming the argument expressions.",0,{"inputs":[{"name":"expr"},{"name":"expr"}],"output":{"name":"expr"}}],[11,"or","","Builds an OR node around two arguments, consuming the argument expressions.",0,{"inputs":[{"name":"expr"},{"name":"expr"}],"output":{"name":"expr"}}],[11,"evaluate","","Evaluates the expression with a particular set of terminal assignments. If any terminals are not assigned, they default to `false`.",0,{"inputs":[{"name":"self"},{"name":"hashmap"}],"output":{"name":"bool"}}],[11,"simplify_via_laws","","Simplify an expression in a relatively cheap way using well-known logic identities.",0,{"inputs":[{"name":"self"}],"output":{"name":"expr"}}],[11,"simplify_via_bdd","","Simplify an expression via a roundtrip through a `BDD`. This procedure is more effective than `Expr::simplify_via_laws()`, but more expensive. This roundtrip will implicitly simplify an arbitrarily complicated function (by construction, as the BDD is built), and then find a quasi-minimal set of terms using cubelist-based reduction. For example:",0,{"inputs":[{"name":"self"}],"output":{"name":"expr"}}],[11,"map","","Map terminal values using the specified mapping function.",0,{"inputs":[{"name":"self"},{"name":"f"}],"output":{"name":"expr"}}],[11,"clone","","",3,{"inputs":[{"name":"self"}],"output":{"name":"bdd"}}],[11,"fmt","","",3,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Produce a new, empty, BDD.",3,{"inputs":[],"output":{"name":"bdd"}}],[11,"terminal","","Produce a function within the BDD representing the terminal `t`. If this terminal has been used in the BDD before, the same `BDDFunc` will be returned.",3,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"bddfunc"}}],[11,"constant","","Produce a function within the BDD representing the constant value `val`.",3,{"inputs":[{"name":"self"},{"name":"bool"}],"output":{"name":"bddfunc"}}],[11,"not","","Produce a function within the BDD representing the logical complement of the function `n`.",3,{"inputs":[{"name":"self"},{"name":"bddfunc"}],"output":{"name":"bddfunc"}}],[11,"and","","Produce a function within the BDD representing the logical AND of the functions `a` and `b`.",3,{"inputs":[{"name":"self"},{"name":"bddfunc"},{"name":"bddfunc"}],"output":{"name":"bddfunc"}}],[11,"or","","Produce a function within the BDD representing the logical OR of the functions `a` and `b`.",3,{"inputs":[{"name":"self"},{"name":"bddfunc"},{"name":"bddfunc"}],"output":{"name":"bddfunc"}}],[11,"implies","","Produce a function within the BDD representing the logical implication `a` -> `b`.",3,{"inputs":[{"name":"self"},{"name":"bddfunc"},{"name":"bddfunc"}],"output":{"name":"bddfunc"}}],[11,"sat","","Check whether the function `f` within the BDD is satisfiable.",3,{"inputs":[{"name":"self"},{"name":"bddfunc"}],"output":{"name":"bool"}}],[11,"restrict","","Return a new function based on `f` but with the given label forced to the given value.",3,{"inputs":[{"name":"self"},{"name":"bddfunc"},{"name":"t"},{"name":"bool"}],"output":{"name":"bddfunc"}}],[11,"from_expr","","Produce a function within the BDD representing the given expression `e`, which may contain ANDs, ORs, NOTs, terminals, and constants.",3,{"inputs":[{"name":"self"},{"name":"expr"}],"output":{"name":"bddfunc"}}],[11,"evaluate","","Evaluate the function `f` in the BDD with the given terminal assignments. Any terminals not specified in `values` default to `false`.",3,{"inputs":[{"name":"self"},{"name":"bddfunc"},{"name":"hashmap"}],"output":{"name":"bool"}}],[11,"sat_one","","Compute an assignment for terminals which satisfies 'f'.  If satisfiable, this function returns a HashMap with the assignments (true, false) for terminals unless a terminal's assignment does not matter for satisfiability. If 'f' is not satisfiable, returns None.",3,{"inputs":[{"name":"self"},{"name":"bddfunc"}],"output":{"generics":["hashmap"],"name":"option"}}],[11,"to_expr","","Convert the BDD to a minimized sum-of-products expression.",3,{"inputs":[{"name":"self"},{"name":"bddfunc"}],"output":{"name":"expr"}}],[11,"to_dot","","Export BDD to `dot` format (from the graphviz package) to enable visualization.",3,{"inputs":[{"name":"self"},{"name":"bddfunc"}],"output":{"name":"string"}}],[11,"new","","Create a new `PersistedBDD`.",4,{"inputs":[],"output":{"name":"persistedbdd"}}],[11,"bdd","","Return the inner BDD.",4,{"inputs":[{"name":"self"}],"output":{"name":"bdd"}}],[11,"bdd_mut","","Return the inner BDD.",4,{"inputs":[{"name":"self"}],"output":{"name":"bdd"}}],[11,"persist","","Persist (at least) all labels and nodes in the BDD necessary to fully describe BDD function `f`. More records than strictly necessary may be written out.",4,{"inputs":[{"name":"self"},{"name":"bddfunc"},{"name":"bddoutput"}],"output":{"name":"result"}}],[11,"persist_all","","Persist all labels and nodes in the BDD.",4,{"inputs":[{"name":"self"},{"name":"bddoutput"}],"output":{"name":"result"}}],[11,"new","","Create a new `BDDLoader` wrapping the given `bdd`. The `BDDLoader` holds a mutable reference to `bdd` until destroyed. `bdd` must be empty initially.",5,{"inputs":[{"name":"bdd"}],"output":{"name":"bddloader"}}],[11,"inject_label","","Inject a new label into the BDD. The `id` must be the next consecutive `id`; i.e., labels must be injected in the order they were dumped to a `BDDOutput`.",5,{"inputs":[{"name":"self"},{"name":"t"},{"name":"u64"}],"output":null}],[11,"inject_node","","Inject a new node into the BDD. The `id` must be the next consecutive `id`; i.e., nodes must be injected in the order they were dumped to a `BDDOutput`.",5,{"inputs":[{"name":"self"},{"name":"bddfunc"},{"name":"u64"},{"name":"bddfunc"},{"name":"bddfunc"}],"output":null}],[11,"clone","","",1,{"inputs":[{"name":"self"}],"output":{"name":"cubevar"}}],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",1,{"inputs":[{"name":"self"},{"name":"cubevar"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",1,{"inputs":[{"name":"self"},{"name":"cubevar"}],"output":{"generics":["ordering"],"name":"option"}}],[11,"cmp","","",1,{"inputs":[{"name":"self"},{"name":"cubevar"}],"output":{"name":"ordering"}}],[11,"clone","","",6,{"inputs":[{"name":"self"}],"output":{"name":"cube"}}],[11,"fmt","","",6,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",2,{"inputs":[{"name":"self"}],"output":{"name":"cubemergeresult"}}],[11,"fmt","","",2,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",2,{"inputs":[{"name":"self"},{"name":"cubemergeresult"}],"output":{"name":"bool"}}],[11,"ne","","",2,{"inputs":[{"name":"self"},{"name":"cubemergeresult"}],"output":{"name":"bool"}}],[11,"true_cube","","Construct an always-true cube (all variables are `DontCare`) for `vars` variables.",6,{"inputs":[{"name":"usize"}],"output":{"name":"cube"}}],[11,"vars","","Return an iterator over variable assignments.",6,{"inputs":[{"name":"self"}],"output":{"generics":["cubevar"],"name":"iter"}}],[11,"merge_with","","Attempt to merge this cube with another, which may cancel one or the other (if completely covered), expand one or the other (if possible, to increase the number of `DontCare`s and thus simplify the final expression), or merge the two into a single cube, or do nothing.",6,{"inputs":[{"name":"self"},{"name":"cube"}],"output":{"name":"cubemergeresult"}}],[11,"with_var","","Return a new cube equal to this cube, but with the particular variable",6,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"cubevar"}],"output":{"name":"cube"}}],[11,"eq","","",6,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",6,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"generics":["ordering"],"name":"option"}}],[11,"cmp","","",6,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"ordering"}}],[11,"clone","","",7,{"inputs":[{"name":"self"}],"output":{"name":"cubelist"}}],[11,"fmt","","",7,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",7,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"bool"}}],[11,"new","","Construct a new, empty, cube list (equivalent to a constant `false`).",7,{"inputs":[],"output":{"name":"cubelist"}}],[11,"from_list","","Construct a cube list from a list of `Cube` structs.",7,null],[11,"cubes","","Return an iterator over all cubes.",7,{"inputs":[{"name":"self"}],"output":{"generics":["cube"],"name":"iter"}}],[11,"merge","","Merge this cube list with another, canceling or merging cubes where possible. The resulting cube list is not guaranteed to be minimal (that is the set-cover problem, which is NP-Complete), but is reduced somewhat by a very simple reduction/merging algorithm.",7,{"inputs":[{"name":"self"},{"name":"cubelist"}],"output":{"name":"cubelist"}}],[11,"with_var","","",7,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"cubevar"}],"output":{"name":"cubelist"}}],[6,"BDDFunc","","A `BDDFunc` is a function index within a particular `BDD`. It must only be used with the `BDD` instance which produced it.",null,null],[17,"BDD_ZERO","","A special terminal `BDDFunc` which is constant `false` (zero).",null,null],[17,"BDD_ONE","","A special terminal `BDDFunc` which is constant `true` (one).",null,null],[8,"BDDOutput","","The `BDDOutput` trait provides an interface to inform a listener about new BDD nodes that are created. It allows the user to persist a BDD to a stream (e.g., a log or trace file) as a long-running process executes. A `BDDOutput` instance may be provided to all BDD operations.",null,null],[10,"write_label","","",8,{"inputs":[{"name":"self"},{"name":"t"},{"name":"u64"}],"output":{"name":"result"}}],[10,"write_node","","",8,{"inputs":[{"name":"self"},{"name":"bddfunc"},{"name":"u64"},{"name":"bddfunc"},{"name":"bddfunc"}],"output":{"name":"result"}}]],"paths":[[4,"Expr"],[4,"CubeVar"],[4,"CubeMergeResult"],[3,"BDD"],[3,"PersistedBDD"],[3,"BDDLoader"],[3,"Cube"],[3,"CubeList"],[8,"BDDOutput"]]};
initSearch(searchIndex);
